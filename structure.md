# 各機械類模倣データ仕様書（案）
この仕様書は、GTS内にて使用する交通信号制御機（以下、制御機と記す）・押ボタン箱・車両用感知器（以下、感知器と記す）、交通信号機（以下、信号機と記す）の内部で保持するデータの仕様を定めるための覚書のようなものである。あくまでこれは1つの案であるため、今後変更になる可能性がある。詳しくはGitの改訂履歴をチェックすること。
備忘録扱いになっているため、他人に理解してもらう前提では書いていない。その点、ご理解いただきたい。

## 制御機のデータ仕様書
制御機は、1つの制御機に対して複数の信号機を操作することができるものとする。この複数において、理論上の制限値を設定しない。
基本的に1つの制御機に対して登録できる制御方法は1つとなるが、夜間点滅制御やプログラム多段制御などに対応させるため、実装上は1つの制御機に対して複数の制御方法を登録することができるように調整する。この制御方法1つを、「**サイクル（Cycle）**」と記す。

### 制御機が保持できるデータ（TrafficControllerクラス）
まず、大前提として制御機は複数のサイクルを一元管理できるものとする。以下、開発言語であるJavaを基準として、データの種類を示す。

#### 登録された複数のサイクル（cycles）
**Cycle**クラスのインスタンスを**HashMap**で管理するものとする。順番を問わないため素の物で十分とした。
HashMapのキーは、自由に設定することができる**String**型の文字列とし、（実装上）サイクル名の重複は禁止する。2バイト文字もUTF-8で受け付けるようにする。なお、Cycleクラスの中身については後述する。

#### 制御機名称（name）
**String**型とし、こちらも2バイト文字を格納できるようにする。

#### 制御機カラー（color）
**Color**クラスのインスタンスをこの中に代入する。なお、このColorはAWTのColorであり、JavaFXではない。（テクスチャ作成時にBufferedTextureを使用する関係上）

#### 制御機のテクスチャ（texture）
**BufferedTexture**クラスのインスタンスとする。レンダー（RenderTrafficController）側で適宜この入れ物を使用していくものとする。

#### 検知信号（detected）
**boolean**型で格納されており、デフォルトはfalse。押ボタン箱、感知器などが車両や歩行者を検知した場合、その機器に制御機が登録（アタッチ）されていれば検知信号が送信され、このdetectedがtrueとなる。

#### 検知ティック（detectedTick）
**long**型で格納されており、検知信号を最初に受信したときのTickが格納される。初期値0。例えば、検知から5秒後、といった条件を指定したい場合に、フェーズの方の継続条件に「`if (detected && ticks - detectedTick > 5 * 20) return false`」とか記せば実現可能。

#### 開始からのティック数（ticks）
**long**型で格納されており、初期値は0となる。サイクルが制御機によって開始されるとこの値が1ずつ増加していく。

※系統制御に関しては現在仕様が定まっていないため、今後考慮していくものとする。

## サイクルのデータ仕様書
サイクルは、1つのサイクルに対して1つ以上の状態を持つ。この状態を、「**フェーズ（Phase）**」と記す。
サイクルはこの1つ以上の状態の組み合わせによって成り立つ。また、サイクルは開始条件を持つ。ただしデフォルトでは開始条件は常に実行（＝環境に関係なく実行）となっている。
開始条件を変更したい場合はクラスを継承して作成する。

### サイクルが保持できるデータ（Cycleクラス）

#### 登録された複数のフェーズ（phases）
**ArrayList**で複数の**Phase**クラスのインスタンスを格納するものとする。添字の少ない順に実行されていき、最後まで到達するとこのサイクルは終了したとみなされる。

#### サイクル名称（name）
制御機に登録される際に使用される名前を、**String**型で指定する。

#### 現在のフェーズ番号（nowPhase）
**long**型で現在現示しているフェーズの番号を格納する。基本的にこの数値は制御機側から変更される。

#### サイクル開始条件（メソッド: canStart）
引数として、「**登録されている制御機**（controller）」「**押ボタン箱・感知器による信号を検知したかどうか**（detected:boolean）」「**登録されている制御機が設置されている場所のワールドインスタンス**（world）」が渡される。

このメソッドはbooleanを返すことになっており、このサイクルを開始する条件を満たしている場合はtrueを返す。それ以外の場合はfalseを返す。

制御機は、現在のサイクル終了後、登録されている全サイクルに対してこのメソッドを呼び出す。その際、trueと返した制御機が発生した時点でそのサイクルを次のサイクルとして判断し、開始を試みる。従って、同一条件で2つ以上のサイクルがtrueを返した際、HashMapの特性によってどのサイクルが選ばれるかは不定である。

## フェーズのデータ仕様書
フェーズは、ある特定のタイミングの時に点灯させるべき信号タイプと、このフェーズを継続するための条件を格納する。
点灯させるべき信号機は複数あるのが前提だが、どの信号機を関連付けるかに関しては「**チャンネル**（Channel）」という概念を導入する。

信号機側で設定した「チャンネル」と同一のチャンネルをチェックし、そのチャンネルの信号を切り替える役目が制御機となる。

### フェーズが保持できるデータ（Phaseクラス）
フェーズは継続条件をメソッドで指定できるようにするため(予定)、Phaseクラスは**Abstract**なクラスとする。

#### フェーズ名称（name）
サイクルに登録される際に使用される名前を、**String**型で指定する。

#### 各チャンネルごとの信号（channels）
それぞれのチャンネルを集約し、**HashMap**型のハッシュ配列として扱う。キーは**Long**とし、整数を入力させるものとする。負の数は予約済みとして扱い、0を禁止するため、使用可能な値は「1～LONG_MAX」とする。この限界値判定処理は内部で実装するものとする（したがって、getter/setterでのみ値の変更を可能とする）。

各チャンネルに対して点灯するパターンは、「LightObjects」クラスのインターフェースを格納するものとする。このクラスの仕様については、信号機の欄で記す。

#### フェーズ開始経過ティック数（ticks）
このフェーズに切り替わってから経過したTickが、**long**型で格納されている。デフォルトは0。

#### フェーズ継続条件（メソッド: shouldContinue）
引数として、「**登録されている制御機**（controller）」、「**サイクルが開始してからの経過Tick数**（totalTicks:int）」、「**押ボタン箱・感知器による信号を検知したかどうか**（detected:boolean）」、「**制御機が登録されているワールドのインスタンス（world）**」の3つを受け取る。

このメソッドは、制御機にこのフェーズが登録されたサイクルが登録されているとき、制御機からサイクルを通して1Tickごとに呼び出される。従ってこのメソッドはなるべく早く終わらせるべきであり、重い処理を入れてはならない。

このメソッドはbooleanを返す必要がある。まだこのフェーズを終わらせてはならない場合はtrueを返し、フェーズを終了可能な状態となった場合はfalseを返す。

このメソッドに関しては抽象メソッドとしており、必ず実装しなくてはならない。オリジナルの条件を作る場合は組み込みのクラスではなくこの抽象クラス「Phase」を継承し、このメソッドを実装すること。

## 押ボタン箱のデータ仕様書
執筆中

## 感知器のデータ仕様書
執筆中

## 信号機のデータ仕様書
信号機は、その信号機が表示すべき**モデル**のデータと、その信号機がアタッチするべき制御機の情報を保持し、またその制御機が制御する対象となるチャンネルに関する情報も保持している。

### 信号機が保持できるデータ（TrafficLightクラス）
#### 信号機モデルコンフィグ（config）
**ModelConfig**型で格納する。この型は自作であり、簡単に言えばJSONでモデルの場所やテクスチャの場所などを指定するものである。詳細は後述。

#### 信号機チャンネル（channel）
**long**型で格納する。指定可能なチャンネルはフェーズ参照。

#### アタッチしている交通信号制御機（contoller）
**TrafficController**あるいは**TileEntityTrafficController**のクラスインスタンスが入ることを予定している（どちらを入れるかは未定）。恐らく後者が入る（座標などの追加情報も付与されるが反面撤去された場合につじつまが合わなくなる）

## モデルコンフィグについて（ModelConfigクラス）
このクラスは、基本的にRTMのJSONファイルと同じように、モデルの場所やモデルのテクスチャ、LightObjectsについて格納をするコンフィグファイルである。詳しい仕様はサンプルJSONファイルなどをチェックしてほしい。

### LightObjectsについて
JSONでは以下のように入れ子になっている。

```
{
    ...,
    "lightObjects": {
        "green": ["g300"],
        "yellow": ["y300"],
        ...
    },
    ...
}
```

このオブジェクトは、キー名をLightObjectsの名称とし、その中に配列を1つ保持している（Java側ではArrayListとして保管し、中身のデータ型はStringとする）。このデータはMQOオブジェクトにおいてそのLightObjectsの際に光らせるべきオブジェクト名称を入れる。そうすることで、フェーズでこれを指定する項目があり、そのフェーズになった際にこのLightObjectsをもとにして信号機の現示を変更することになる。

## その他
まだ仕様がきちんと定まっていないため、頻繁に改訂するかもしれない。
